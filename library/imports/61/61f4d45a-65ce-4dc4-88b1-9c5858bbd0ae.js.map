{"version":3,"sources":["assets\\hall\\scripts\\framework\\libs\\cryptoTs\\lib\\BufferedBlockAlgorithm.ts"],"names":[],"mappings":"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","file":"","sourceRoot":"/","sourcesContent":["import { WordArray } from './WordArray';\r\nimport { Utf8 } from '../enc/Utf8';\r\nimport { BufferedBlockAlgorithmConfig } from './BufferedBlockAlgorithmConfig';\r\n\r\nexport abstract class BufferedBlockAlgorithm {\r\n    public _minBufferSize = 0;\r\n\r\n    public _data: WordArray;\r\n\r\n    public _nDataBytes: number;\r\n\r\n    public cfg: BufferedBlockAlgorithmConfig;\r\n\r\n    abstract _doProcessBlock(wordArray: Array<number>, offset: number): void;\r\n\r\n    constructor(cfg?: BufferedBlockAlgorithmConfig) {\r\n        this.cfg = Object.assign({\r\n            blockSize: 1\r\n        }, cfg);\r\n\r\n        // Initial values\r\n        this._data = new WordArray();\r\n        this._nDataBytes = 0;\r\n    }\r\n\r\n    /**\r\n     * Resets this block algorithm's data buffer to its initial state.\r\n     *\r\n     * @example\r\n     *\r\n     *     bufferedBlockAlgorithm.reset();\r\n     */\r\n    reset() {\r\n        // Initial values\r\n        this._data = new WordArray();\r\n        this._nDataBytes = 0;\r\n    }\r\n\r\n    /**\r\n     * Adds new data to this block algorithm's buffer.\r\n     *\r\n     * @param data The data to append. Strings are converted to a WordArray using UTF-8.\r\n     *\r\n     * @example\r\n     *\r\n     *     bufferedBlockAlgorithm._append('data');\r\n     *     bufferedBlockAlgorithm._append(wordArray);\r\n     */\r\n    _append(data: string | WordArray) {\r\n        // Convert string to WordArray, else assume WordArray already\r\n        if(typeof data === 'string') {\r\n            data = Utf8.parse(data);\r\n        }\r\n\r\n        // Append\r\n        this._data.concat(data);\r\n        this._nDataBytes += data.sigBytes;\r\n    }\r\n\r\n    /**\r\n     * Processes available data blocks.\r\n     *\r\n     * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\r\n     *\r\n     * @param doFlush Whether all blocks and partial blocks should be processed.\r\n     *\r\n     * @return The processed data.\r\n     *\r\n     * @example\r\n     *\r\n     *     let processedData = bufferedBlockAlgorithm._process();\r\n     *     let processedData = bufferedBlockAlgorithm._process(!!'flush');\r\n     */\r\n    _process(doFlush?: boolean): WordArray {\r\n        if(!this.cfg.blockSize) {\r\n            throw new Error('missing blockSize in config');\r\n        }\r\n\r\n        // Shortcuts\r\n        const blockSizeBytes = this.cfg.blockSize * 4;\r\n\r\n        // Count blocks ready\r\n        let nBlocksReady = this._data.sigBytes / blockSizeBytes;\r\n        if (doFlush) {\r\n            // Round up to include partial blocks\r\n            nBlocksReady = Math.ceil(nBlocksReady);\r\n        } else {\r\n            // Round down to include only full blocks,\r\n            // less the number of blocks that must remain in the buffer\r\n            nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\r\n        }\r\n\r\n        // Count words ready\r\n        const nWordsReady = nBlocksReady * this.cfg.blockSize;\r\n\r\n        // Count bytes ready\r\n        const nBytesReady = Math.min(nWordsReady * 4, this._data.sigBytes);\r\n\r\n        // Process blocks\r\n        let processedWords;\r\n        if (nWordsReady) {\r\n            for (let offset = 0; offset < nWordsReady; offset += this.cfg.blockSize) {\r\n                // Perform concrete-algorithm logic\r\n                this._doProcessBlock(this._data.words, offset);\r\n            }\r\n\r\n            // Remove processed words\r\n            processedWords = this._data.words.splice(0, nWordsReady);\r\n            this._data.sigBytes -= nBytesReady;\r\n        }\r\n\r\n        // Return processed words\r\n        return new WordArray(processedWords, nBytesReady);\r\n    }\r\n\r\n    /**\r\n     * Creates a copy of this object.\r\n     *\r\n     * @return The clone.\r\n     *\r\n     * @example\r\n     *\r\n     *     let clone = bufferedBlockAlgorithm.clone();\r\n     */\r\n    clone(): BufferedBlockAlgorithm {\r\n        const clone = this.constructor();\r\n\r\n        for(const attr in this) {\r\n            if(this.hasOwnProperty(attr)) {\r\n                clone[attr] = this[attr];\r\n            }\r\n        }\r\n\r\n        clone._data = this._data.clone();\r\n\r\n        return clone;\r\n    }\r\n}"]}