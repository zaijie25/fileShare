{"version":3,"sources":["assets\\hall\\scripts\\logic\\core\\component\\PolygonButtonHit.js"],"names":["cc","Class","Component","editor","CC_EDITOR","menu","requireComponent","PolygonCollider","properties","onLoad","node","_oldHitTest","_hitTest","bind","polygonHitTest","point","listener","polygonCollider","getComponent","isNotTouchMask","mask","parent","i","index","comp","Mask","enabledInHierarchy","convertToNodeSpaceAR","x","getContentSize","width","y","height","Intersection","pointInPolygon","points"],"mappings":";;;;;;AAAA;AACAA,EAAE,CAACC,KAAH,CAAS;AACL,aAASD,EAAE,CAACE,SADP;AAELC,EAAAA,MAAM,EAAEC,SAAS,IAAI;AACjBC,IAAAA,IAAI,EAAE,8CADW;AAEjBC,IAAAA,gBAAgB,EAAGN,EAAE,CAACO;AAFL,GAFhB;AAMLC,EAAAA,UAAU,EAAE,EANP;;AAQL;AACJ;AACA;AACIC,EAAAA,MAXK,oBAWI;AACL,SAAKC,IAAL,CAAUC,WAAV,GAAwB,KAAKD,IAAL,CAAUE,QAAV,CAAmBC,IAAnB,CAAwB,KAAKH,IAA7B,CAAxB;AACA,SAAKA,IAAL,CAAUE,QAAV,GAAqB,KAAKE,cAAL,CAAoBD,IAApB,CAAyB,KAAKH,IAA9B,CAArB;AACH,GAdI;;AAgBL;AACJ;AACA;AACA;AACA;AACII,EAAAA,cArBK,0BAqBUC,KArBV,EAqBiBC,QArBjB,EAqB2B;AAC5B,QAAIC,eAAe,GAAG,KAAKC,YAAL,CAAkBlB,EAAE,CAACO,eAArB,CAAtB;AACA,QAAIY,cAAc,GAAG,KAArB;;AACA,QAAIF,eAAJ,EAAqB;AACjB,UAAID,QAAQ,IAAIA,QAAQ,CAACI,IAAzB,EAA+B;AAC3B,YAAIA,IAAI,GAAGJ,QAAQ,CAACI,IAApB;AACA,YAAIC,MAAM,GAAG,IAAb;;AACA,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBD,MAAM,IAAIC,CAAC,GAAGF,IAAI,CAACG,KAAnC,EAA0C,EAAED,CAAF,EAAKD,MAAM,GAAGA,MAAM,CAACA,MAA/D,EAAuE,CACtE,CAJ0B,CAK3B;;;AACA,YAAIA,MAAM,KAAKD,IAAI,CAACV,IAApB,EAA0B;AACtB,cAAIc,IAAI,GAAGH,MAAM,CAACH,YAAP,CAAoBlB,EAAE,CAACyB,IAAvB,CAAX;AACAN,UAAAA,cAAc,GAAIK,IAAI,IAAIA,IAAI,CAACE,kBAAd,GAAoCF,IAAI,CAACZ,QAAL,CAAcG,KAAd,CAApC,GAA2D,IAA5E;AACH,SAHD,CAIA;AAJA,aAKK;AACDC,YAAAA,QAAQ,CAACI,IAAT,GAAgB,IAAhB;AACAD,YAAAA,cAAc,GAAG,IAAjB;AACH;AACJ,OAfD,MAgBK;AACDA,QAAAA,cAAc,GAAG,IAAjB;AACH;;AACD,UAAGA,cAAH,EAAkB;AACdJ,QAAAA,KAAK,GAAG,KAAKY,oBAAL,CAA0BZ,KAA1B,CAAR;AACAA,QAAAA,KAAK,CAACa,CAAN,IAAW,KAAKC,cAAL,GAAsBC,KAAtB,GAA8B,CAAzC;AACAf,QAAAA,KAAK,CAACgB,CAAN,IAAW,KAAKF,cAAL,GAAsBG,MAAtB,GAA+B,CAA1C;AACA,eAAOhC,EAAE,CAACiC,YAAH,CAAgBC,cAAhB,CAA+BnB,KAA/B,EAAsCE,eAAe,CAACkB,MAAtD,CAAP;AACH,OALD,MAKK;AACD,eAAO,KAAP;AACH;AACJ,KA5BD,MA4BO;AACH,aAAO,KAAKxB,WAAL,CAAiBI,KAAjB,EAAwBC,QAAxB,CAAP;AACH;AACJ;AAvDI,CAAT","sourceRoot":"/","sourcesContent":["// 挂载节点需要先挂载cc.PolygonCollider, 通过polygonCollider.points确定不规则范围\r\ncc.Class({\r\n    extends: cc.Component,\r\n    editor: CC_EDITOR && {\r\n        menu: 'i18n:MAIN_MENU.component.ui/PolygonButtonHit',\r\n        requireComponent : cc.PolygonCollider,\r\n    },\r\n    properties: {\r\n    },\r\n    /**\r\n     * 加载\r\n     */\r\n    onLoad() {\r\n        this.node._oldHitTest = this.node._hitTest.bind(this.node);\r\n        this.node._hitTest = this.polygonHitTest.bind(this.node);\r\n    },\r\n\r\n    /**\r\n     * 不规则多边形触摸测试\r\n     * @param {触摸点} point \r\n     * @param {监听} listener \r\n     */\r\n    polygonHitTest(point, listener) {\r\n        var polygonCollider = this.getComponent(cc.PolygonCollider);\r\n        var isNotTouchMask = false;\r\n        if (polygonCollider) {\r\n            if (listener && listener.mask) {\r\n                var mask = listener.mask;\r\n                var parent = this;\r\n                for (var i = 0; parent && i < mask.index; ++i, parent = parent.parent) {\r\n                }\r\n                // find mask parent, should hit test it\r\n                if (parent === mask.node) {\r\n                    var comp = parent.getComponent(cc.Mask);\r\n                    isNotTouchMask = (comp && comp.enabledInHierarchy) ? comp._hitTest(point) : true;\r\n                }\r\n                // mask parent no longer exists\r\n                else {\r\n                    listener.mask = null;\r\n                    isNotTouchMask = true;\r\n                }\r\n            }\r\n            else {\r\n                isNotTouchMask = true;\r\n            }\r\n            if(isNotTouchMask){\r\n                point = this.convertToNodeSpaceAR(point);\r\n                point.x -= this.getContentSize().width / 2;\r\n                point.y -= this.getContentSize().height / 2;\r\n                return cc.Intersection.pointInPolygon(point, polygonCollider.points);\r\n            }else{\r\n                return false;\r\n            }\r\n        } else {\r\n            return this._oldHitTest(point, listener);\r\n        }\r\n    }\r\n});"]}