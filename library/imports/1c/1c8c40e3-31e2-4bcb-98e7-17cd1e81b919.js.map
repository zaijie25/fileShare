{"version":3,"sources":["assets\\hall\\scripts\\framework\\libs\\cryptoTs\\algo\\EvpKDF.ts"],"names":[],"mappings":";;;;;;;AAAA,8CAA6C;AAE7C,6BAA4B;AAc5B;IAGI;;;;;;;;;;OAUG;IACH,gBAAY,GAA0B;QAClC,IAAI,CAAC,GAAG,GAAG,MAAM,CAAC,MAAM,CAAC;YACrB,OAAO,EAAE,GAAG,GAAG,EAAE;YACjB,MAAM,EAAE,SAAG;YACX,UAAU,EAAE,CAAC;SAChB,EAAE,GAAG,CAAC,CAAC;IACZ,CAAC;IAED;;;;;;;;;;;OAWG;IACH,wBAAO,GAAP,UAAQ,QAA4B,EAAE,IAAwB;QAC1D,cAAc;QACd,IAAM,MAAM,GAAG,IAAW,IAAI,CAAC,GAAG,CAAC,MAAO,EAAE,CAAC;QAE7C,iBAAiB;QACjB,IAAM,UAAU,GAAG,IAAI,qBAAS,EAAE,CAAC;QAEnC,eAAe;QACf,IAAI,KAAK,CAAC;QACV,OAAM,UAAU,CAAC,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,OAAO,EAAE;YAC9C,IAAG,KAAK,EAAE;gBACN,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;aACxB;YACD,KAAK,GAAG,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;YAC/C,MAAM,CAAC,KAAK,EAAE,CAAC;YAEf,aAAa;YACb,KAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,UAAU,EAAE,CAAC,EAAE,EAAE;gBACzC,KAAK,GAAG,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;gBAC/B,MAAM,CAAC,KAAK,EAAE,CAAC;aAClB;YAED,UAAU,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;SAC5B;QACD,UAAU,CAAC,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,OAAO,GAAG,CAAC,CAAC;QAE3C,OAAO,UAAU,CAAC;IACtB,CAAC;IACL,aAAC;AAAD,CA9DA,AA8DC,IAAA;AA9DY,wBAAM","file":"","sourceRoot":"/","sourcesContent":["import { WordArray } from '../lib/WordArray';\r\nimport { Hasher } from '../lib/Hasher';\r\nimport { MD5 } from './MD5';\r\n\r\nexport interface OptionalEvpKDFConfig {\r\n    keySize?: number;\r\n    hasher?: typeof Hasher;\r\n    iterations?: number;\r\n}\r\n\r\nexport interface EvpKDFConfig extends OptionalEvpKDFConfig {\r\n    keySize: number;\r\n    hasher: typeof Hasher;\r\n    iterations: number;\r\n}\r\n\r\nexport class EvpKDF {\r\n    public cfg: EvpKDFConfig;\r\n\r\n    /**\r\n     * Initializes a newly created key derivation function.\r\n     *\r\n     * @param cfg (Optional) The configuration options to use for the derivation.\r\n     *\r\n     * @example\r\n     *\r\n     *     let kdf = EvpKDF.create();\r\n     *     let kdf = EvpKDF.create({ keySize: 8 });\r\n     *     let kdf = EvpKDF.create({ keySize: 8, iterations: 1000 });\r\n     */\r\n    constructor(cfg?: OptionalEvpKDFConfig) {\r\n        this.cfg = Object.assign({\r\n            keySize: 128 / 32,\r\n            hasher: MD5,\r\n            iterations: 1\r\n        }, cfg);\r\n    }\r\n\r\n    /**\r\n     * Derives a key from a password.\r\n     *\r\n     * @param password The password.\r\n     * @param salt A salt.\r\n     *\r\n     * @return The derived key.\r\n     *\r\n     * @example\r\n     *\r\n     *     let key = kdf.compute(password, salt);\r\n     */\r\n    compute(password: WordArray | string, salt: WordArray | string): WordArray {\r\n        // Init hasher\r\n        const hasher = new (<any> this.cfg.hasher)();\r\n\r\n        // Initial values\r\n        const derivedKey = new WordArray();\r\n\r\n        // Generate key\r\n        let block;\r\n        while(derivedKey.words.length < this.cfg.keySize) {\r\n            if(block) {\r\n                hasher.update(block);\r\n            }\r\n            block = hasher.update(password).finalize(salt);\r\n            hasher.reset();\r\n\r\n            // Iterations\r\n            for(let i = 1; i < this.cfg.iterations; i++) {\r\n                block = hasher.finalize(block);\r\n                hasher.reset();\r\n            }\r\n\r\n            derivedKey.concat(block);\r\n        }\r\n        derivedKey.sigBytes = this.cfg.keySize * 4;\r\n\r\n        return derivedKey;\r\n    }\r\n}"]}