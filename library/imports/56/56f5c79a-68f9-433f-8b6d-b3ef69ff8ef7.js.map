{"version":3,"sources":["assets\\hall\\scripts\\framework\\libs\\cryptoTs\\lib\\CipherParams.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA,+BAA8B;AAQ9B;IAAkC,gCAAI;IAmBlC;;;;;;;;;;;;;;;;;;OAkBG;IACH,sBAAmB,YAAmC;QAAtD,YACI,iBAAO,SAWV;QATG,KAAI,CAAC,UAAU,GAAG,YAAY,CAAC,UAAU,CAAC;QAC1C,KAAI,CAAC,GAAG,GAAG,YAAY,CAAC,GAAG,CAAC;QAC5B,KAAI,CAAC,EAAE,GAAG,YAAY,CAAC,EAAE,CAAC;QAC1B,KAAI,CAAC,IAAI,GAAG,YAAY,CAAC,IAAI,CAAC;QAC9B,KAAI,CAAC,SAAS,GAAG,YAAY,CAAC,SAAS,CAAC;QACxC,KAAI,CAAC,IAAI,GAAG,YAAY,CAAC,IAAI,CAAC;QAC9B,KAAI,CAAC,OAAO,GAAG,YAAY,CAAC,OAAO,CAAC;QACpC,KAAI,CAAC,SAAS,GAAG,YAAY,CAAC,SAAS,CAAC;QACxC,KAAI,CAAC,SAAS,GAAG,YAAY,CAAC,SAAS,CAAC;;IAC5C,CAAC;IAEM,6BAAM,GAAb,UAAc,gBAA8B;QACxC,IAAG,gBAAgB,CAAC,UAAU,KAAK,SAAS,EAAE;YAC1C,IAAI,CAAC,UAAU,GAAG,gBAAgB,CAAC,UAAU,CAAC;SACjD;QAED,IAAG,gBAAgB,CAAC,GAAG,KAAK,SAAS,EAAE;YACnC,IAAI,CAAC,GAAG,GAAG,gBAAgB,CAAC,GAAG,CAAC;SACnC;QAED,IAAG,gBAAgB,CAAC,EAAE,KAAK,SAAS,EAAE;YAClC,IAAI,CAAC,EAAE,GAAG,gBAAgB,CAAC,EAAE,CAAC;SACjC;QAED,IAAG,gBAAgB,CAAC,IAAI,KAAK,SAAS,EAAE;YACpC,IAAI,CAAC,IAAI,GAAG,gBAAgB,CAAC,IAAI,CAAC;SACrC;QAED,IAAG,gBAAgB,CAAC,SAAS,KAAK,SAAS,EAAE;YACzC,IAAI,CAAC,SAAS,GAAG,gBAAgB,CAAC,SAAS,CAAC;SAC/C;QAED,IAAG,gBAAgB,CAAC,IAAI,KAAK,SAAS,EAAE;YACpC,IAAI,CAAC,IAAI,GAAG,gBAAgB,CAAC,IAAI,CAAC;SACrC;QAED,IAAG,gBAAgB,CAAC,OAAO,KAAK,SAAS,EAAE;YACvC,IAAI,CAAC,OAAO,GAAG,gBAAgB,CAAC,OAAO,CAAC;SAC3C;QAED,IAAG,gBAAgB,CAAC,SAAS,KAAK,SAAS,EAAE;YACzC,IAAI,CAAC,SAAS,GAAG,gBAAgB,CAAC,SAAS,CAAC;SAC/C;QAED,IAAG,gBAAgB,CAAC,SAAS,KAAK,SAAS,EAAE;YACzC,IAAI,CAAC,SAAS,GAAG,gBAAgB,CAAC,SAAS,CAAC;SAC/C;QAGD,OAAO,IAAI,CAAC;IAChB,CAAC;IAED;;;;;;;;;;;;;;OAcG;IACI,+BAAQ,GAAf,UAAgB,SAAqB;QACjC,IAAG,SAAS,EAAE;YACV,OAAO,SAAS,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;SACpC;aAAM,IAAG,IAAI,CAAC,SAAS,EAAE;YACtB,OAAO,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;SACzC;aAAM;YACH,MAAM,IAAI,KAAK,CAAC,yEAAyE,CAAC,CAAC;SAC9F;IACL,CAAC;IACL,mBAAC;AAAD,CArHA,AAqHC,CArHiC,WAAI,GAqHrC;AArHY,oCAAY","file":"","sourceRoot":"/","sourcesContent":["import { Base } from './Base';\r\nimport { CipherParamsInterface } from './CipherParamsInterface';\r\nimport { WordArray } from './WordArray';\r\nimport { Cipher } from './Cipher';\r\nimport { BlockCipherMode } from '../mode/BlockCipherMode';\r\nimport { Padding } from '../pad/Padding';\r\nimport { Formatter } from '../format/Formatter';\r\n\r\nexport class CipherParams extends Base implements CipherParamsInterface {\r\n    ciphertext?: WordArray;\r\n\r\n    key?: WordArray | string;\r\n\r\n    iv?: WordArray;\r\n\r\n    salt?: WordArray | string;\r\n\r\n    algorithm?: typeof Cipher;\r\n\r\n    mode?: typeof BlockCipherMode;\r\n\r\n    padding?: Padding;\r\n\r\n    blockSize?: number;\r\n\r\n    formatter?: Formatter;\r\n\r\n    /**\r\n     * Initializes a newly created cipher params object.\r\n     *\r\n     * @param cipherParams An object with any of the possible cipher parameters.\r\n     *\r\n     * @example\r\n     *\r\n     *     let cipherParams = CipherParams.create({\r\n     *         ciphertext: ciphertextWordArray,\r\n     *         key: keyWordArray,\r\n     *         iv: ivWordArray,\r\n     *         salt: saltWordArray,\r\n     *         algorithm: AESAlgorithm,\r\n     *         mode: CBC,\r\n     *         padding: PKCS7,\r\n     *         blockSize: 4,\r\n     *         formatter: OpenSSLFormatter\r\n     *     });\r\n     */\r\n    public constructor(cipherParams: CipherParamsInterface) {\r\n        super();\r\n\r\n        this.ciphertext = cipherParams.ciphertext;\r\n        this.key = cipherParams.key;\r\n        this.iv = cipherParams.iv;\r\n        this.salt = cipherParams.salt;\r\n        this.algorithm = cipherParams.algorithm;\r\n        this.mode = cipherParams.mode;\r\n        this.padding = cipherParams.padding;\r\n        this.blockSize = cipherParams.blockSize;\r\n        this.formatter = cipherParams.formatter;\r\n    }\r\n\r\n    public extend(additionalParams: CipherParams): CipherParams {\r\n        if(additionalParams.ciphertext !== undefined) {\r\n            this.ciphertext = additionalParams.ciphertext;\r\n        }\r\n\r\n        if(additionalParams.key !== undefined) {\r\n            this.key = additionalParams.key;\r\n        }\r\n\r\n        if(additionalParams.iv !== undefined) {\r\n            this.iv = additionalParams.iv;\r\n        }\r\n\r\n        if(additionalParams.salt !== undefined) {\r\n            this.salt = additionalParams.salt;\r\n        }\r\n\r\n        if(additionalParams.algorithm !== undefined) {\r\n            this.algorithm = additionalParams.algorithm;\r\n        }\r\n\r\n        if(additionalParams.mode !== undefined) {\r\n            this.mode = additionalParams.mode;\r\n        }\r\n\r\n        if(additionalParams.padding !== undefined) {\r\n            this.padding = additionalParams.padding;\r\n        }\r\n\r\n        if(additionalParams.blockSize !== undefined) {\r\n            this.blockSize = additionalParams.blockSize;\r\n        }\r\n\r\n        if(additionalParams.formatter !== undefined) {\r\n            this.formatter = additionalParams.formatter;\r\n        }\r\n\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Converts this cipher params object to a string.\r\n     *\r\n     * @param formatter (Optional) The formatting strategy to use.\r\n     *\r\n     * @return The stringified cipher params.\r\n     *\r\n     * @throws Error If neither the formatter nor the default formatter is set.\r\n     *\r\n     * @example\r\n     *\r\n     *     let string = cipherParams + '';\r\n     *     let string = cipherParams.toString();\r\n     *     let string = cipherParams.toString(CryptoJS.format.OpenSSL);\r\n     */\r\n    public toString(formatter?: Formatter): string {\r\n        if(formatter) {\r\n            return formatter.stringify(this);\r\n        } else if(this.formatter) {\r\n            return this.formatter.stringify(this);\r\n        } else {\r\n            throw new Error('cipher needs a formatter to be able to convert the result into a string');\r\n        }\r\n    }\r\n}"]}