{
  "__type__": "cc.TextAsset",
  "_name": "async.d",
  "_objFlags": 0,
  "_native": "",
  "text": "// Generated by typings\r\n// Source: https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/251be47a58782e02a2553d3babef382cdbf5d98e/async/index.d.ts\r\ninterface Dictionary<T> { [key: string]: T; }\r\n\r\ninterface ErrorCallback<T> { (err?: T): void; }\r\ninterface AsyncBooleanResultCallback<E> { (err?: E, truthValue?: boolean): void; }\r\ninterface AsyncResultCallback<T, E> { (err?: E, result?: T): void; }\r\ninterface AsyncResultArrayCallback<T, E> { (err?: E, results?: (T | undefined)[]): void; }\r\ninterface AsyncResultObjectCallback<T, E> { (err: E | undefined, results: Dictionary<T | undefined>): void; }\r\n\r\ninterface AsyncFunction<T, E> { (callback: (err?: E, result?: T) => void): void; }\r\ninterface AsyncIterator<T, E> { (item: T, callback: ErrorCallback<E>): void; }\r\ninterface AsyncForEachOfIterator<T, E> { (item: T, key: number|string, callback: ErrorCallback<E>): void; }\r\ninterface AsyncResultIterator<T, R, E> { (item: T, callback: AsyncResultCallback<R, E>): void; }\r\ninterface AsyncMemoIterator<T, R, E> { (memo: R | undefined, item: T, callback: AsyncResultCallback<R, E>): void; }\r\ninterface AsyncBooleanIterator<T, E> { (item: T, callback: AsyncBooleanResultCallback<E>): void; }\r\n\r\ninterface AsyncWorker<T, E> { (task: T, callback: ErrorCallback<E>): void; }\r\ninterface AsyncVoidFunction<E> { (callback: ErrorCallback<E>): void; }\r\n\r\ninterface AsyncQueue<T> {\r\n    length(): number;\r\n    started: boolean;\r\n    running(): number;\r\n    idle(): boolean;\r\n    concurrency: number;\r\n    push<E>(task: T, callback?: ErrorCallback<E>): void;\r\n    push<E>(task: T, callback?: AsyncResultCallback<T, E>): void;\r\n    push<E>(task: T[], callback?: ErrorCallback<E>): void;\r\n    unshift<E>(task: T, callback?: ErrorCallback<E>): void;\r\n    unshift<E>(task: T[], callback?: ErrorCallback<E>): void;\r\n    saturated: () => any;\r\n    empty: () => any;\r\n    drain: () => any;\r\n    paused: boolean;\r\n    pause(): void\r\n    resume(): void;\r\n    kill(): void;\r\n    workersList(): {\r\n        data: T,\r\n        callback: Function\r\n    }[];\r\n    error(error: Error, data: any): void;\r\n    unsaturated(): void;\r\n    buffer: number;\r\n}\r\n\r\ninterface AsyncPriorityQueue<T> {\r\n    length(): number;\r\n    concurrency: number;\r\n    started: boolean;\r\n    paused: boolean;\r\n    push<E>(task: T, priority: number, callback?: AsyncResultArrayCallback<T, E>): void;\r\n    push<E>(task: T[], priority: number, callback?: AsyncResultArrayCallback<T, E>): void;\r\n    saturated: () => any;\r\n    empty: () => any;\r\n    drain: () => any;\r\n    running(): number;\r\n    idle(): boolean;\r\n    pause(): void;\r\n    resume(): void;\r\n    kill(): void;\r\n    workersList(): {\r\n        data: T,\r\n        priority: number,\r\n        callback: Function\r\n    }[];\r\n    error(error: Error, data: any): void;\r\n    unsaturated(): void;\r\n    buffer: number;\r\n}\r\n\r\ninterface AsyncCargo {\r\n    length(): number;\r\n    payload?: number;\r\n    push(task: any, callback? : Function): void;\r\n    push(task: any[], callback? : Function): void;\r\n    saturated(): void;\r\n    empty(): void;\r\n    drain(): void;\r\n    idle(): boolean;\r\n    pause(): void;\r\n    resume(): void;\r\n    kill(): void;\r\n}\r\n\r\ninterface Async {\r\n\r\n    // Collections\r\n    each<T, E>(arr: T[] | IterableIterator<T>, iterator: AsyncIterator<T, E>, callback?: ErrorCallback<E>): void;\r\n    each<T, E>(arr: Dictionary<T>, iterator: AsyncIterator<T, E>, callback?: ErrorCallback<E>): void;\r\n    eachSeries: typeof async.each;\r\n    eachLimit<T, E>(arr: T[] | IterableIterator<T>, limit: number, iterator: AsyncIterator<T, E>, callback?: ErrorCallback<E>): void;\r\n    eachLimit<T, E>(arr: Dictionary<T>, limit: number, iterator: AsyncIterator<T, E>, callback?: ErrorCallback<E>): void;\r\n    forEach: typeof async.each;\r\n    forEachSeries: typeof async.each;\r\n    forEachLimit: typeof async.eachLimit;\r\n    forEachOf<T, E>(obj: T[] | IterableIterator<T>, iterator: AsyncForEachOfIterator<T, E>, callback?: ErrorCallback<E>): void;\r\n    forEachOf<T, E>(obj: Dictionary<T>, iterator: AsyncForEachOfIterator<T, E>, callback?: ErrorCallback<E>): void;\r\n    forEachOfSeries: typeof async.forEachOf;\r\n    forEachOfLimit<T, E>(obj: T[] | IterableIterator<T>, limit: number, iterator: AsyncForEachOfIterator<T, E>, callback?: ErrorCallback<E>): void;\r\n    forEachOfLimit<T, E>(obj: Dictionary<T>, limit: number, iterator: AsyncForEachOfIterator<T, E>, callback?: ErrorCallback<E>): void;\r\n    eachOf: typeof async.forEachOf;\r\n    eachOfSeries: typeof async.forEachOf;\r\n    eachOfLimit: typeof async.forEachOfLimit;\r\n    map<T, R, E>(arr: T[] | IterableIterator<T>, iterator: AsyncResultIterator<T, R, E>, callback?: AsyncResultArrayCallback<R, E>): void;\r\n    map<T, R, E>(arr: Dictionary<T>, iterator: AsyncResultIterator<T, R, E>, callback?: AsyncResultArrayCallback<R, E>): void;\r\n    mapSeries: typeof async.map;\r\n    mapLimit<T, R, E>(arr: T[] | IterableIterator<T>, limit: number, iterator: AsyncResultIterator<T, R, E>, callback?: AsyncResultArrayCallback<R, E>): void;\r\n    mapLimit<T, R, E>(arr: Dictionary<T>, limit: number, iterator: AsyncResultIterator<T, R, E>, callback?: AsyncResultArrayCallback<R, E>): void;\r\n    mapValuesLimit<T, R, E>(obj: Dictionary<T>, limit: number, iteratee: (value: T, key: string, callback: AsyncResultCallback<R, E>) => void, callback: AsyncResultObjectCallback<R, E>): void;\r\n    mapValues<T, R, E>(obj: Dictionary<T>, iteratee: (value: T, key: string, callback: AsyncResultCallback<R, E>) => void, callback: AsyncResultObjectCallback<R, E>): void;\r\n    mapValuesSeries: typeof async.mapValues;\r\n    filter<T, E>(arr: T[] | IterableIterator<T>, iterator: AsyncBooleanIterator<T, E>, callback?: AsyncResultArrayCallback<T, E>): void;\r\n    filter<T, E>(arr: Dictionary<T>, iterator: AsyncBooleanIterator<T, E>, callback?: AsyncResultArrayCallback<T, E>): void;\r\n    filterSeries: typeof async.filter;\r\n    filterLimit<T, E>(arr: T[] | IterableIterator<T>, limit: number, iterator: AsyncBooleanIterator<T, E>, callback?: AsyncResultArrayCallback<T, E>): void;\r\n    filterLimit<T, E>(arr: Dictionary<T>, limit: number, iterator: AsyncBooleanIterator<T, E>, callback?: AsyncResultArrayCallback<T, E>): void;\r\n    select: typeof async.filter;\r\n    selectSeries: typeof async.filter;\r\n    selectLimit: typeof async.filterLimit;\r\n    reject: typeof async.filter;\r\n    rejectSeries: typeof async.filter;\r\n    rejectLimit: typeof async.filterLimit;\r\n    reduce<T, R, E>(arr: T[] | IterableIterator<T>, memo: R, iterator: AsyncMemoIterator<T, R, E>, callback?: AsyncResultCallback<R, E>): void;\r\n    inject: typeof async.reduce;\r\n    foldl: typeof async.reduce;\r\n    reduceRight: typeof async.reduce;\r\n    foldr: typeof async.reduce;\r\n    detect<T, E>(arr: T[] | IterableIterator<T>, iterator: AsyncBooleanIterator<T, E>, callback?: AsyncResultCallback<T, E>): void;\r\n    detect<T, E>(arr: Dictionary<T>, iterator: AsyncBooleanIterator<T, E>, callback?: AsyncResultCallback<T, E>): void;\r\n    detectSeries: typeof async.detect;\r\n    detectLimit<T, E>(arr: T[] | IterableIterator<T>, limit: number, iterator: AsyncBooleanIterator<T, E>, callback?: AsyncResultCallback<T, E>): void;\r\n    detectLimit<T, E>(arr: Dictionary<T>, limit: number, iterator: AsyncBooleanIterator<T, E>, callback?: AsyncResultCallback<T, E>): void;\r\n    find: typeof async.detect;\r\n    findSeries: typeof async.detect;\r\n    findLimit: typeof async.detectLimit;\r\n    sortBy<T, V, E>(arr: T[] | IterableIterator<T>, iterator: AsyncResultIterator<T, V, E>, callback?: AsyncResultArrayCallback<T, E>): void;\r\n    some<T, E>(arr: T[] | IterableIterator<T>, iterator: AsyncBooleanIterator<T, E>, callback?: AsyncBooleanResultCallback<E>): void;\r\n    some<T, E>(arr: Dictionary<T>, iterator: AsyncBooleanIterator<T, E>, callback?: AsyncBooleanResultCallback<E>): void;\r\n    someSeries: typeof async.some;\r\n    someLimit<T, E>(arr: T[] | IterableIterator<T>, limit: number, iterator: AsyncBooleanIterator<T, E>, callback?: AsyncBooleanResultCallback<E>): void;\r\n    someLimit<T, E>(arr: Dictionary<T>, limit: number, iterator: AsyncBooleanIterator<T, E>, callback?: AsyncBooleanResultCallback<E>): void;\r\n    any: typeof async.some;\r\n    anySeries: typeof async.someSeries;\r\n    anyLimit: typeof async.someLimit;\r\n    every<T, E>(arr: T[] | IterableIterator<T>, iterator: AsyncBooleanIterator<T, E>, callback?: AsyncBooleanResultCallback<E>): void;\r\n    every<T, E>(arr: Dictionary<T>, iterator: AsyncBooleanIterator<T, E>, callback?: AsyncBooleanResultCallback<E>): void;\r\n    everySeries: typeof async.every;\r\n    everyLimit<T, E>(arr: T[] | IterableIterator<T>, limit: number, iterator: AsyncBooleanIterator<T, E>, callback?: AsyncBooleanResultCallback<E>): void;\r\n    everyLimit<T, E>(arr: Dictionary<T>, limit: number, iterator: AsyncBooleanIterator<T, E>, callback?: AsyncBooleanResultCallback<E>): void;\r\n    all: typeof async.every;\r\n    allSeries: typeof async.every;\r\n    allLimit: typeof async.everyLimit;\r\n\r\n    concat<T, R, E>(arr: T[] | IterableIterator<T>, iterator: AsyncResultIterator<T, R[], E>, callback?: AsyncResultArrayCallback<R, E>): void;\r\n    concat<T, R, E>(arr: Dictionary<T>, iterator: AsyncResultIterator<T, R[], E>, callback?: AsyncResultArrayCallback<R, E>): void;\r\n    concatSeries: typeof async.concat;\r\n\r\n    // Control Flow\r\n    series<T, E>(tasks: AsyncFunction<T, E>[], callback?: AsyncResultArrayCallback<T, E>): void;\r\n    series<T, E>(tasks: Dictionary<AsyncFunction<T, E>>, callback?: AsyncResultObjectCallback<T, E>): void;\r\n    parallel<T, E>(tasks: Array<AsyncFunction<T, E>>, callback?: AsyncResultArrayCallback<T, E>): void;\r\n    parallel<T, E>(tasks: Dictionary<AsyncFunction<T, E>>, callback?: AsyncResultObjectCallback<T, E>): void;\r\n    parallelLimit<T, E>(tasks: Array<AsyncFunction<T, E>>, limit: number, callback?: AsyncResultArrayCallback<T, E>): void;\r\n    parallelLimit<T, E>(tasks: Dictionary<AsyncFunction<T, E>>, limit: number, callback?: AsyncResultObjectCallback<T, E>): void;\r\n    whilst<E>(test: () => boolean, fn: AsyncVoidFunction<E>, callback: ErrorCallback<E>): void;\r\n    doWhilst<E>(fn: AsyncVoidFunction<E>, test: () => boolean, callback: ErrorCallback<E>): void;\r\n    until<E>(test: () => boolean, fn: AsyncVoidFunction<E>, callback: ErrorCallback<E>): void;\r\n    doUntil<E>(fn: AsyncVoidFunction<E>, test: () => boolean, callback: ErrorCallback<E>): void;\r\n    during<E>(test: (testCallback : AsyncBooleanResultCallback<E>) => void, fn: AsyncVoidFunction<E>, callback: ErrorCallback<E>): void;\r\n    doDuring<E>(fn: AsyncVoidFunction<E>, test: (testCallback: AsyncBooleanResultCallback<E>) => void, callback: ErrorCallback<E>): void;\r\n    forever<E>(next: (next : ErrorCallback<E>) => void, errBack: ErrorCallback<E>) : void;\r\n    waterfall<T, E>(tasks: Function[], callback?: AsyncResultCallback<T, E | Error>): void;\r\n    compose(...fns: Function[]): Function;\r\n    seq(...fns: Function[]): Function;\r\n    applyEach(fns: Function[], argsAndCallback: any[]): void;           // applyEach(fns, args..., callback). TS does not support ... for a middle argument. Callback is optional.\r\n    applyEachSeries(fns: Function[], argsAndCallback: any[]): void;     // applyEachSeries(fns, args..., callback). TS does not support ... for a middle argument. Callback is optional.\r\n    queue<T, E>(worker: AsyncWorker<T, E>, concurrency?: number): AsyncQueue<T>;\r\n    queue<T, R, E>(worker: AsyncResultIterator<T, R, E>, concurrency?: number): AsyncQueue<T>;\r\n    priorityQueue<T, E>(worker: AsyncWorker<T, E>, concurrency: number): AsyncPriorityQueue<T>;\r\n    cargo<E>(worker : (tasks: any[], callback : ErrorCallback<E>) => void, payload? : number) : AsyncCargo;\r\n    auto<E>(tasks: any, concurrency?: number, callback?: AsyncResultCallback<any, E>): void;\r\n    autoInject<E>(tasks: any, callback?: AsyncResultCallback<any, E>): void;\r\n    retry<T, E>(opts: number, task: (callback : AsyncResultCallback<T, E>, results: any) => void, callback:  AsyncResultCallback<any, E | Error>): void;\r\n    retry<T, E>(opts: { times: number, interval: number|((retryCount: number) => number) }, task: (callback: AsyncResultCallback<T, E>, results : any) => void, callback:  AsyncResultCallback<any, E | Error>): void;\r\n    retryable<T, E>(opts: number | {times: number, interval: number}, task: AsyncFunction<T, E>): AsyncFunction<T, E | Error>;\r\n    apply<E>(fn: Function, ...arguments: any[]): AsyncFunction<any,E | Error>;\r\n    nextTick(callback: Function, ...args: any[]): void;\r\n    setImmediate: typeof async.nextTick;\r\n\r\n    reflect<T, E>(fn: AsyncFunction<T, E>) : (callback: (err: null, result: {error?: E, value?: T}) => void) => void;\r\n    reflectAll<T, E>(tasks: AsyncFunction<T, E>[]): ((callback: (err: null, result: {error?: E, value?: T}) => void) => void)[];\r\n\r\n    timeout<T, E>(fn: AsyncFunction<T, E>, milliseconds: number, info?: any): AsyncFunction<T, E | Error>;\r\n    timeout<T, R, E>(fn: AsyncResultIterator<T, R, E>, milliseconds: number, info?: any): AsyncResultIterator<T, R, E | Error>;\r\n\r\n    times<T, E> (n: number, iterator: AsyncResultIterator<number, T, E>, callback: AsyncResultArrayCallback<T, E>): void;\r\n    timesSeries<T, E>(n: number, iterator: AsyncResultIterator<number, T, E>, callback: AsyncResultArrayCallback<T, E>): void;\r\n    timesLimit<T, E>(n: number, limit: number, iterator: AsyncResultIterator<number, T, E>, callback: AsyncResultArrayCallback<T, E>): void;\r\n\r\n    transform<T, R, E>(arr: T[], iteratee: (acc: R[], item: T, key: number, callback: (error?: E) => void) => void, callback?: AsyncResultArrayCallback<T, E>): void;\r\n    transform<T, R, E>(arr: T[], acc: R[], iteratee: (acc: R[], item: T, key: number, callback: (error?: E) => void) => void, callback?: AsyncResultArrayCallback<T, E>): void;\r\n\r\n    transform<T, R, E>(arr: {[key: string] : T}, iteratee: (acc: {[key: string] : R}, item: T, key: string, callback: (error?: E) => void) => void, callback?: AsyncResultObjectCallback<T, E>): void;\r\n    transform<T, R, E>(arr: {[key: string] : T}, acc: {[key: string] : R}, iteratee: (acc: {[key: string] : R}, item: T, key: string, callback: (error?: E) => void) => void, callback?: AsyncResultObjectCallback<T, E>): void;\r\n\r\n    race<T, E>(tasks: (AsyncFunction<T, E>)[], callback: AsyncResultCallback<T, E | Error>) : void;\r\n\r\n    // Utils\r\n    memoize(fn: Function, hasher?: Function): Function;\r\n    unmemoize(fn: Function): Function;\r\n    ensureAsync(fn: (... argsAndCallback: any[]) => void): Function;\r\n    constant(...values: any[]): Function;\r\n    asyncify(fn: Function): Function;\r\n    wrapSync(fn: Function): Function;\r\n    log(fn: Function, ...arguments: any[]): void;\r\n    dir(fn: Function, ...arguments: any[]): void;\r\n}\r\n\r\ndeclare var async: Async;\r\n\r\ndeclare module \"async\" {\r\n    export = async;\r\n}\r\n"
}