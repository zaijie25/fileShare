{"version":3,"sources":["assets\\hall\\scripts\\framework\\libs\\cryptoTs\\lib\\SerializableCipher.ts"],"names":[],"mappings":";;;;;;;AAAA,yCAAwC;AAGxC,6CAA4C;AAC5C,+CAA8C;AAG9C;IAAA;IAgIA,CAAC;IAzHG;;;;;;;;;;;;;;;;;;OAkBG;IACW,0BAAO,GAArB,UACI,MAAqB,EACrB,OAA2B,EAC3B,GAAc,EACd,GAAkC;QAElC,wBAAwB;QACxB,IAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,IAAI,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;QAEhD,UAAU;QACV,IAAM,SAAS,GAAG,MAAM,CAAC,eAAe,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;QACtD,IAAM,UAAU,GAAG,SAAS,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;QAE/C,+CAA+C;QAC/C,OAAO,IAAI,2BAAY,CAAC;YACpB,UAAU,EAAE,UAAU;YACtB,GAAG,EAAE,GAAG;YACR,EAAE,EAAE,SAAS,CAAC,GAAG,CAAC,EAAE;YACpB,SAAS,EAAE,MAAM;YACjB,IAAI,EAAS,SAAS,CAAC,GAAI,CAAC,IAAI;YAChC,OAAO,EAAS,SAAS,CAAC,GAAI,CAAC,OAAO;YACtC,SAAS,EAAE,SAAS,CAAC,GAAG,CAAC,SAAS;YAClC,SAAS,EAAE,MAAM,CAAC,MAAM;SAC3B,CAAC,CAAC;IACP,CAAC;IAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OA6BG;IACW,0BAAO,GAArB,UACI,MAAqB,EACrB,UAAiC,EACjC,GAAc,EACd,WAA0C;QAE1C,wBAAwB;QACxB,IAAM,GAAG,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,IAAI,CAAC,GAAG,EAAE,WAAW,CAAC,CAAC;QAErD,IAAG,CAAC,GAAG,CAAC,MAAM,EAAE;YACZ,MAAM,IAAI,KAAK,CAAC,4BAA4B,CAAC,CAAC;SACjD;QAED,iCAAiC;QACjC,UAAU,GAAG,IAAI,CAAC,MAAM,CAAC,UAAU,EAAE,GAAG,CAAC,MAAM,CAAC,CAAC;QAEjD,IAAG,CAAC,UAAU,CAAC,UAAU,EAAE;YACvB,MAAM,IAAI,KAAK,CAAC,gCAAgC,CAAC,CAAC;SACrD;QAED,UAAU;QACV,IAAM,SAAS,GAAG,MAAM,CAAC,eAAe,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,QAAQ,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC;QAEnF,OAAO,SAAS,CAAC;IACrB,CAAC;IAED;;;;;;;;;;;;OAYG;IACW,yBAAM,GAApB,UAAqB,UAAiC,EAAE,MAAiB;QACrE,IAAG,OAAO,UAAU,KAAK,QAAQ,EAAE;YAC/B,OAAO,MAAM,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;SACnC;aAAM;YACH,OAAO,UAAU,CAAC;SACrB;IACL,CAAC;IA9Ha,sBAAG,GAAiC;QAC9C,SAAS,EAAE,CAAC;QACZ,EAAE,EAAE,IAAI,qBAAS,CAAC,EAAE,CAAC;QACrB,MAAM,EAAE,iBAAO;KAClB,CAAC;IA2HN,yBAAC;CAhID,AAgIC,IAAA;AAhIY,gDAAkB","file":"","sourceRoot":"/","sourcesContent":["import { WordArray } from './WordArray';\r\nimport { Cipher } from './Cipher';\r\nimport { BufferedBlockAlgorithmConfig } from './BufferedBlockAlgorithmConfig';\r\nimport { OpenSSL } from '../format/OpenSSL';\r\nimport { CipherParams } from './CipherParams';\r\nimport { Formatter } from '../format/Formatter';\r\n\r\nexport class SerializableCipher {\r\n    public static cfg: BufferedBlockAlgorithmConfig = {\r\n        blockSize: 4,\r\n        iv: new WordArray([]),\r\n        format: OpenSSL\r\n    };\r\n\r\n    /**\r\n     * Encrypts a message.\r\n     *\r\n     * @param cipher The cipher algorithm to use.\r\n     * @param message The message to encrypt.\r\n     * @param key The key.\r\n     * @param cfg (Optional) The configuration options to use for this operation.\r\n     *\r\n     * @return A cipher params object.\r\n     *\r\n     * @example\r\n     *\r\n     *     let ciphertextParams = SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);\r\n     *     let ciphertextParams = SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });\r\n     *     let ciphertextParams = SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, {\r\n     *       iv: iv,\r\n     *       format: CryptoJS.format.OpenSSL\r\n     *     });\r\n     */\r\n    public static encrypt(\r\n        cipher: typeof Cipher,\r\n        message: WordArray | string,\r\n        key: WordArray,\r\n        cfg?: BufferedBlockAlgorithmConfig\r\n    ): CipherParams {\r\n        // Apply config defaults\r\n        const config = Object.assign({}, this.cfg, cfg);\r\n\r\n        // Encrypt\r\n        const encryptor = cipher.createEncryptor(key, config);\r\n        const ciphertext = encryptor.finalize(message);\r\n\r\n        // Create and return serializable cipher params\r\n        return new CipherParams({\r\n            ciphertext: ciphertext,\r\n            key: key,\r\n            iv: encryptor.cfg.iv,\r\n            algorithm: cipher,\r\n            mode: (<any> encryptor.cfg).mode,\r\n            padding: (<any> encryptor.cfg).padding,\r\n            blockSize: encryptor.cfg.blockSize,\r\n            formatter: config.format\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Decrypts serialized ciphertext.\r\n     *\r\n     * @param cipher The cipher algorithm to use.\r\n     * @param ciphertext The ciphertext to decrypt.\r\n     * @param key The key.\r\n     * @param cfg (Optional) The configuration options to use for this operation.\r\n     *\r\n     * @return The plaintext.\r\n     *\r\n     * @example\r\n     *\r\n     *     let plaintext = SerializableCipher.decrypt(\r\n     *         AESAlgorithm,\r\n     *         formattedCiphertext,\r\n     *         key, {\r\n     *             iv: iv,\r\n     *             format: CryptoJS.format.OpenSSL\r\n     *         }\r\n     *     );\r\n     *\r\n     *     let plaintext = SerializableCipher.decrypt(\r\n     *         AESAlgorithm,\r\n     *         ciphertextParams,\r\n     *         key, {\r\n     *             iv: iv,\r\n     *             format: CryptoJS.format.OpenSSL\r\n     *         }\r\n     *     );\r\n     */\r\n    public static decrypt(\r\n        cipher: typeof Cipher,\r\n        ciphertext: CipherParams | string,\r\n        key: WordArray,\r\n        optionalCfg?: BufferedBlockAlgorithmConfig\r\n    ): WordArray {\r\n        // Apply config defaults\r\n        const cfg = Object.assign({}, this.cfg, optionalCfg);\r\n\r\n        if(!cfg.format) {\r\n            throw new Error('could not determine format');\r\n        }\r\n\r\n        // Convert string to CipherParams\r\n        ciphertext = this._parse(ciphertext, cfg.format);\r\n\r\n        if(!ciphertext.ciphertext) {\r\n            throw new Error('could not determine ciphertext');\r\n        }\r\n\r\n        // Decrypt\r\n        const plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);\r\n\r\n        return plaintext;\r\n    }\r\n\r\n    /**\r\n     * Converts serialized ciphertext to CipherParams,\r\n     * else assumed CipherParams already and returns ciphertext unchanged.\r\n     *\r\n     * @param ciphertext The ciphertext.\r\n     * @param format The formatting strategy to use to parse serialized ciphertext.\r\n     *\r\n     * @return The unserialized ciphertext.\r\n     *\r\n     * @example\r\n     *\r\n     *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);\r\n     */\r\n    public static _parse(ciphertext: CipherParams | string, format: Formatter): CipherParams {\r\n        if(typeof ciphertext === 'string') {\r\n            return format.parse(ciphertext);\r\n        } else {\r\n            return ciphertext;\r\n        }\r\n    }\r\n}"]}