{"version":3,"sources":["assets\\hall\\scripts\\logic\\core\\net\\tcp\\int64.ts"],"names":[],"mappings":"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","file":"","sourceRoot":"/","sourcesContent":["//     Int64.js\r\n//\r\n//     Copyright (c) 2012 Robert Kieffer\r\n//     MIT License - http://opensource.org/licenses/mit-license.php\r\n\r\n/**\r\n * Support for handling 64-bit int numbers in Javascript (node.js)\r\n *\r\n * JS Numbers are IEEE-754 binary double-precision floats, which limits the\r\n * range of values that can be represented with integer precision to:\r\n *\r\n * 2^^53 <= N <= 2^53\r\n *\r\n * Int64 objects wrap a node Buffer that holds the 8-bytes of int64 data.  These\r\n * objects operate directly on the buffer which means that if they are created\r\n * using an existing buffer then setting the value will modify the Buffer, and\r\n * vice-versa.\r\n *\r\n * Internal Representation\r\n *\r\n * The internal buffer format is Big Endian.  I.e. the most-significant byte is\r\n * at buffer[0], the least-significant at buffer[7].  For the purposes of\r\n * converting to/from JS native numbers, the value is assumed to be a signed\r\n * integer stored in 2's complement form.\r\n *\r\n * For details about IEEE-754 see:\r\n * http://en.wikipedia.org/wiki/Double_precision_floating-point_format\r\n */\r\n\r\n//\r\n// Int64\r\n//\r\nclass Int64\r\n{\r\n    // Useful masks and values for bit twiddling\r\n    public static MASK31:number =  0x7fffffff;\r\n    public static VAL31:number = 0x80000000;\r\n    public static MASK32:number =  0xffffffff;\r\n    public static VAL32:number = 0x100000000;\r\n    public static MAX_INT:number = Math.pow(2, 53);\r\n    public static MIN_INT:number = -Math.pow(2, 53);\r\n    private static _HEX:Array<any> = new Array<any>();\r\n\r\n    public buffer:Array<number>;\r\n    public offset:number;\r\n\r\n    /**\r\n     * Constructor accepts any of the following argument types:\r\n     *\r\n     * new Int64(buffer[, offset=0]) - Existing Buffer with byte offset\r\n     * new Int64(Uint8Array[, offset=0]) - Existing Uint8Array with a byte offset\r\n     * new Int64(string)             - Hex string (throws if n is outside int64 range)\r\n     * new Int64(number)             - Number (throws if n is outside int64 range)\r\n     * new Int64(hi, lo)             - Raw bits as two 32-bit values\r\n     */\r\n    public constructor(a1:any, a2?:any)\r\n    {\r\n        this._buildHex();\r\n        if (a1 instanceof Array)\r\n        {\r\n            this.buffer = a1;\r\n            this.offset = a2 || 0;\r\n        }\r\n        else if (Object.prototype.toString.call(a1) == '[object Uint8Array]')\r\n        {\r\n            // Under Browserify, Buffers can extend Uint8Arrays rather than an\r\n            // instance of Buffer. We could assume the passed in Uint8Array is actually\r\n            // a buffer but that won't handle the case where a raw Uint8Array is passed\r\n            // in. We construct a new Buffer just in case.\r\n            this.buffer = Array.apply([], a1);\r\n            this.offset = a2 || 0;\r\n        }\r\n        else\r\n        {\r\n            this.buffer = this.buffer || [];\r\n            this.offset = 0;\r\n            this.setValue.apply(this, arguments);\r\n        }\r\n    }\r\n\r\n    // Map for converting hex octets to strings\r\n    private _buildHex():void\r\n    {\r\n        //Int64._HEX = [];\r\n        for (var i = 0; i < 256; i++) {\r\n          Int64._HEX[i] = (i > 0xF ? '' : '0') + i.toString(16);\r\n        }\r\n    }\r\n\r\n  /**\r\n   * Do in-place 2's compliment.  See\r\n   * http://en.wikipedia.org/wiki/Two's_complement\r\n   */\r\n  private _2scomp()\r\n  {\r\n    var b = this.buffer, o = this.offset, carry = 1;\r\n    for (var i = o + 7; i >= o; i--) {\r\n      var v = (b[i] ^ 0xff) + carry;\r\n      b[i] = v & 0xff;\r\n      carry = v >> 8;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the value. Takes any of the following arguments:\r\n   *\r\n   * setValue(string) - A hexidecimal string\r\n   * setValue(number) - Number (throws if n is outside int64 range)\r\n   * setValue(hi, lo) - Raw bits as two 32-bit values\r\n   */\r\n  public setValue(hi:any, lo?:any):void {\r\n    var negate:boolean = false;\r\n    if (arguments.length == 1) {\r\n      if (typeof(hi) == 'number') {\r\n        // Simplify bitfield retrieval by using abs() value.  We restore sign\r\n        // later\r\n        negate = hi < 0;\r\n        hi = Math.abs(hi);\r\n        lo = hi % Int64.VAL32;\r\n        hi = hi / Int64.VAL32;\r\n        if (hi > Int64.VAL32) throw new RangeError(hi  + ' is outside Int64 range');\r\n        hi = hi | 0;\r\n      } else if (typeof(hi) == 'string') {\r\n        hi = (hi + '').replace(/^0x/, '');\r\n        lo = hi.substr(-8);\r\n        hi = hi.length > 8 ? hi.substr(0, hi.length - 8) : '';\r\n        hi = parseInt(hi, 16);\r\n        lo = parseInt(lo, 16);\r\n      } else {\r\n        throw new Error(hi + ' must be a Number or String');\r\n      }\r\n    }\r\n\r\n    // Technically we should throw if hi or lo is outside int32 range here, but\r\n    // it's not worth the effort. Anything past the 32'nd bit is ignored.\r\n\r\n    // Copy bytes to buffer\r\n    var b = this.buffer, o = this.offset;\r\n    for (var i = 7; i >= 0; i--) {\r\n      b[o+i] = lo & 0xff;\r\n      lo = i == 4 ? hi : lo >>> 8;\r\n    }\r\n\r\n    // Restore sign of passed argument\r\n    if (negate) this._2scomp();\r\n  }\r\n\r\n  /**\r\n   * Convert to a native JS number.\r\n   *\r\n   * WARNING: Do not expect this value to be accurate to integer precision for\r\n   * large (positive or negative) numbers!\r\n   *\r\n   * @param allowImprecise If true, no check is performed to verify the\r\n   * returned value is accurate to integer precision.  If false, imprecise\r\n   * numbers (very large positive or negative numbers) will be forced to +/-\r\n   * Infinity.\r\n   */\r\n  public toNumber(allowImprecise:boolean=false):number {\r\n    var b = this.buffer, o = this.offset;\r\n\r\n    // Running sum of octets, doing a 2's complement\r\n    var negate = b[o] & 0x80, x = 0, carry = 1;\r\n    for (var i = 7, m = 1; i >= 0; i--, m *= 256) {\r\n      var v = b[o+i];\r\n\r\n      // 2's complement for negative numbers\r\n      if (negate) {\r\n        v = (v ^ 0xff) + carry;\r\n        carry = v >> 8;\r\n        v = v & 0xff;\r\n      }\r\n\r\n      x += v * m;\r\n    }\r\n\r\n    // Return Infinity if we've lost integer precision\r\n    if (!allowImprecise && x >= Int64.MAX_INT) {\r\n      return negate ? -Infinity : Infinity;\r\n    }\r\n\r\n    return negate ? -x : x;\r\n  }\r\n\r\n  /**\r\n   * Convert to a JS Number. Returns +/-Infinity for values that can't be\r\n   * represented to integer precision.\r\n   */\r\n  public valueOf():number {\r\n    return this.toNumber(false);\r\n  }\r\n\r\n  /**\r\n   * Return string value\r\n   *\r\n   * @param radix Just like Number#toString()'s radix\r\n   */\r\n  public toString(radix:number=10):string {\r\n    return this.valueOf().toString(radix);\r\n  }\r\n\r\n  /**\r\n   * Return a string showing the buffer octets, with MSB on the left.\r\n   *\r\n   * @param sep separator string. default is '' (empty string)\r\n   */\r\n  public toOctetString(sep:string=''):string {\r\n    var out = new Array(8);\r\n    var b = this.buffer, o = this.offset;\r\n    for (var i = 0; i < 8; i++) {\r\n      out[i] = Int64._HEX[b[o+i]];\r\n    }\r\n    return out.join(sep || '');\r\n  }\r\n\r\n  /**\r\n   * Returns the int64's 8 bytes in a buffer.\r\n   *\r\n   * @param {bool} [rawBuffer=false]  If no offset and this is true, return the internal buffer.  Should only be used if\r\n   *                                  you're discarding the Int64 afterwards, as it breaks encapsulation.\r\n   */\r\n  public toBuffer(rawBuffer:boolean=false):Array<number> {\r\n    if (rawBuffer && this.offset === 0) return this.buffer;\r\n\r\n    var out = Array.call([], this.buffer);\r\n    return out;\r\n  }\r\n\r\n  /**\r\n   * Returns a number indicating whether this comes before or after or is the\r\n   * same as the other in sort order.\r\n   *\r\n   * @param {Int64} other  Other Int64 to compare.\r\n   */\r\n  public compare(other:Int64):number {\r\n\r\n    // If sign bits differ ...\r\n    if ((this.buffer[this.offset] & 0x80) != (other.buffer[other.offset] & 0x80)) {\r\n      return other.buffer[other.offset] - this.buffer[this.offset];\r\n    }\r\n\r\n    // otherwise, compare bytes lexicographically\r\n    for (var i = 0; i < 8; i++) {\r\n      if (this.buffer[this.offset+i] !== other.buffer[other.offset+i]) {\r\n        return this.buffer[this.offset+i] - other.buffer[other.offset+i];\r\n      }\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Returns a boolean indicating if this integer is equal to other.\r\n   *\r\n   * @param {Int64} other  Other Int64 to compare.\r\n   */\r\n  public equals(other:Int64):boolean {\r\n    return this.compare(other) === 0;\r\n  }\r\n\r\n  /**\r\n   * Pretty output in console.log\r\n   */\r\n  public inspect():string {\r\n    return '[Int64 value:' + this + ' octets:' + this.toOctetString(' ') + ']';\r\n  }\r\n}\r\nexport default Int64"]}