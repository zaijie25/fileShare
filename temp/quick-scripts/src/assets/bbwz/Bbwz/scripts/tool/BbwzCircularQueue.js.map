{"version":3,"sources":["assets\\bbwz\\Bbwz\\scripts\\tool\\BbwzCircularQueue.ts"],"names":[],"mappings":";;;;;;AAAA,uBAAuB;AACvB;IAKI,0BAA0B;IAC1B,2BAAmB,OAAe;QAAf,YAAO,GAAP,OAAO,CAAQ;QAL1B,UAAK,GAAQ,EAAE,CAAC;QAChB,SAAI,GAAG,CAAC,CAAC,CAAC;QACV,SAAI,GAAG,CAAC,CAAC,CAAC,CAAM,eAAe;QAInC,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;IACpB,CAAC;IAED,qBAAqB;IACd,mCAAO,GAAd,UAAe,KAAQ;QACnB,IAAI,IAAI,CAAC,MAAM,EAAE;YACb,OAAO,KAAK,CAAC;QACjB,IAAI,IAAI,CAAC,OAAO,EAAE;YACd,IAAI,CAAC,IAAI,GAAG,CAAC,CAAC;QAClB,IAAI,CAAC,IAAI,GAAG,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC;QAC3C,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC;QAC9B,OAAO,IAAI,CAAC;IAChB,CAAC;IAED,8CAA8C;IACvC,mCAAO,GAAd;QACI,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,EAAC;YAChB,IAAI,IAAI,CAAC,IAAI,KAAK,IAAI,CAAC,IAAI,EAAC;gBACxB,IAAI,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC;gBACf,IAAI,CAAC,IAAI,GAAE,CAAC,CAAC,CAAC;aACjB;iBACG;gBACA,IAAI,CAAC,IAAI,GAAG,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC;aAC9C;YACD,OAAO,IAAI,CAAC;SACf;QACD,OAAO,KAAK,CAAC;IACjB,CAAC;IAED,UAAU;IACH,iCAAK,GAAZ;QACI,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;YACf,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACrC,CAAC;IAED,SAAS;IACF,gCAAI,GAAX;QACI,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;YACf,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACrC,CAAC;IAEM,kCAAM,GAAb;QACI,IAAI,IAAI,GAAG,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,OAAO,KAAK,IAAI,CAAC,IAAI,CAAC;QACxD,IAAI,IAAI;YACJ,MAAM,CAAC,KAAK,CAAC,oCAAoC,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAO,uBAAuB;QAEnG,OAAO,IAAI,CAAC;IAChB,CAAC;IAEM,mCAAO,GAAd;QACI,OAAO,IAAI,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC;IAC5B,CAAC;IAED,sBAAW,qCAAM;aAAjB;YACI,IAAI,IAAI,CAAC,IAAI,IAAI,CAAC,CAAC,IAAK,IAAI,CAAC,IAAI,IAAI,CAAC,CAAC;gBACnC,OAAO,CAAC,CAAC;YACb,OAAO,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,GAAG,CAAC,CAAC;QACrC,CAAC;;;OAAA;IAEM,iCAAK,GAAZ;QACI,IAAI,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC;QACf,IAAI,CAAC,IAAI,GAAE,CAAC,CAAC,CAAC;IAClB,CAAC;IACL,wBAAC;AAAD,CAtEA,AAsEC,IAAA","file":"","sourceRoot":"/","sourcesContent":["// 循环队列 用于频繁作shift()的数据\r\nexport default class BbwzCircularQueue<T>{\r\n    private queue: T[] = [];\r\n    private tail = -1;      \r\n    private head = -1;      // [0, maxSize]\r\n    \r\n    // size队列长度, 在不确定多长时可以设置大点\r\n    constructor(public maxSize: number){\r\n        this.queue = [];\r\n    }\r\n\r\n    // 队尾插入一个元素 队尾不是指数组尾部\r\n    public enQueue(value: T){\r\n        if (this.isFull())\r\n            return false;\r\n        if (this.isEmpty())\r\n            this.head = 0;\r\n        this.tail = (this.tail + 1) % this.maxSize;\r\n        this.queue[this.tail] = value;\r\n        return true;\r\n    }\r\n\r\n    // 从队头删除一个元素 通常先q.front()获取头元素 然后q.deQueue()删除\r\n    public deQueue(){\r\n        if (!this.isEmpty()){\r\n            if (this.head === this.tail){\r\n                this.head = -1;\r\n                this.tail= -1;\r\n            }\r\n            else{\r\n                this.head = (this.head + 1) % this.maxSize;\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // 从队首获取元素\r\n    public front(): T{\r\n        if (!this.isEmpty())\r\n            return this.queue[this.head];\r\n    }\r\n\r\n    // 获取队尾元素\r\n    public rear(): T{\r\n        if (!this.isEmpty())\r\n            return this.queue[this.tail];\r\n    }\r\n\r\n    public isFull(){\r\n        let flag = (this.tail + 1) % this.maxSize === this.head;\r\n        if (flag)\r\n            Logger.error(\"BbwzCircularQueue isFull, check it\", this.maxSize);       // maxSize设置小了, 会导致数据丢失\r\n\r\n        return flag;\r\n    }\r\n\r\n    public isEmpty(){\r\n        return this.head === -1;\r\n    }\r\n\r\n    public get length(){\r\n        if (this.tail == -1 &&  this.head == -1)\r\n            return 0;\r\n        return this.tail - this.head + 1;\r\n    }\r\n\r\n    public clear(){\r\n        this.head = -1;\r\n        this.tail= -1;\r\n    }\r\n}"]}