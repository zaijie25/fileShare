{"version":3,"sources":["assets\\hall\\scripts\\framework\\libs\\cryptoTs\\lib\\Hasher.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA,mEAAkE;AAIlE;IAAqC,0BAAsB;IAwBvD;;;;;;;;OAQG;IACH,gBAAmB,GAAkC;QAArD;QACI,wBAAwB;QACxB,kBAAM,MAAM,CAAC,MAAM,CAAC;YAChB,SAAS,EAAE,GAAG,GAAG,EAAE;SACtB,EAAE,GAAG,CAAC,CAAC,SAIX;QAFG,qBAAqB;QACrB,KAAI,CAAC,KAAK,EAAE,CAAC;;IACjB,CAAC;IAxCD;;;;;;;;;;OAUG;IACW,oBAAa,GAA3B,UAA4B,MAAqB;QAC7C,SAAS,MAAM,CAAC,OAA2B,EAAE,GAAkC;YAC3E,IAAM,WAAW,GAAQ,MAAM,CAAC;YAEhC,IAAM,cAAc,GAAQ,IAAI,WAAW,CAAC,GAAG,CAAC,CAAC;YAEjD,OAAO,cAAc,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;QAC5C,CAAC;QAED,OAAO,MAAM,CAAC;IAClB,CAAC;IAqBD;;;;;;;;;;;OAWG;IACH,uBAAM,GAAN,UAAO,aAAiC;QACpC,SAAS;QACT,IAAI,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC;QAE5B,kBAAkB;QAClB,IAAI,CAAC,QAAQ,EAAE,CAAC;QAEhB,YAAY;QACZ,OAAO,IAAI,CAAC;IAChB,CAAC;IAED;;;;;;;;;;;;;OAaG;IACI,yBAAQ,GAAf,UAAgB,aAAiC;QAC7C,uBAAuB;QACvB,IAAG,aAAa,EAAE;YACd,IAAI,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC;SAC/B;QAED,gCAAgC;QAChC,IAAM,IAAI,GAAG,IAAI,CAAC,WAAW,EAAE,CAAC;QAEhC,OAAO,IAAI,CAAC;IAChB,CAAC;IAGL,aAAC;AAAD,CA7FA,AA6FC,CA7FoC,+CAAsB,GA6F1D;AA7FqB,wBAAM","file":"","sourceRoot":"/","sourcesContent":["import { BufferedBlockAlgorithm } from './BufferedBlockAlgorithm';\r\nimport { BufferedBlockAlgorithmConfig } from './BufferedBlockAlgorithmConfig';\r\nimport { WordArray } from './WordArray';\r\n\r\nexport abstract class Hasher extends BufferedBlockAlgorithm {\r\n    /**\r\n     * Creates a shortcut function to a hasher's object interface.\r\n     *\r\n     * @param hasher The hasher to create a helper for.\r\n     *\r\n     * @return The shortcut function.\r\n     *\r\n     * @example\r\n     *\r\n     *     let SHA256 = Hasher._createHelper(SHA256);\r\n     */\r\n    public static _createHelper(hasher: typeof Hasher) {\r\n        function helper(message: WordArray | string, cfg?: BufferedBlockAlgorithmConfig) {\r\n            const hasherClass: any = hasher;\r\n\r\n            const hasherInstance: any = new hasherClass(cfg);\r\n\r\n            return hasherInstance.finalize(message);\r\n        }\r\n\r\n        return helper;\r\n    }\r\n\r\n    /**\r\n     * Initializes a newly created hasher.\r\n     *\r\n     * @param cfg (Optional) The configuration options to use for this hash computation.\r\n     *\r\n     * @example\r\n     *\r\n     *     let hasher = CryptoJS.algo.SHA256.create();\r\n     */\r\n    public constructor(cfg?: BufferedBlockAlgorithmConfig) {\r\n        // Apply config defaults\r\n        super(Object.assign({\r\n            blockSize: 512 / 32\r\n        }, cfg));\r\n\r\n        // Set initial values\r\n        this.reset();\r\n    }\r\n\r\n    /**\r\n     * Updates this hasher with a message.\r\n     *\r\n     * @param messageUpdate The message to append.\r\n     *\r\n     * @return This hasher.\r\n     *\r\n     * @example\r\n     *\r\n     *     hasher.update('message');\r\n     *     hasher.update(wordArray);\r\n     */\r\n    update(messageUpdate: WordArray | string): Hasher {\r\n        // Append\r\n        this._append(messageUpdate);\r\n\r\n        // Update the hash\r\n        this._process();\r\n\r\n        // Chainable\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Finalizes the hash computation.\r\n     * Note that the finalize operation is effectively a destructive, read-once operation.\r\n     *\r\n     * @param messageUpdate (Optional) A final message update.\r\n     *\r\n     * @return The hash.\r\n     *\r\n     * @example\r\n     *\r\n     *     let hash = hasher.finalize();\r\n     *     let hash = hasher.finalize('message');\r\n     *     let hash = hasher.finalize(wordArray);\r\n     */\r\n    public finalize(messageUpdate: WordArray | string): WordArray {\r\n        // Final message update\r\n        if(messageUpdate) {\r\n            this._append(messageUpdate);\r\n        }\r\n\r\n        // Perform concrete-hasher logic\r\n        const hash = this._doFinalize();\r\n\r\n        return hash;\r\n    }\r\n\r\n    public abstract _doFinalize(): WordArray;\r\n}"]}