{"version":3,"sources":["assets\\hall\\scripts\\framework\\libs\\cryptoTs\\format\\OpenSSL.ts"],"names":[],"mappings":";;;;;;;AACA,oDAAmD;AACnD,8CAA6C;AAC7C,wCAAuC;AAEvC;IAAA;IAgEA,CAAC;IA/DG;;;;;;;;;;OAUG;IACW,iBAAS,GAAvB,UAAwB,YAA0B;QAC9C,IAAG,CAAC,YAAY,CAAC,UAAU,EAAE;YACzB,MAAM,IAAI,KAAK,CAAC,8BAA8B,CAAC,CAAC;SACnD;QAED,YAAY;QACZ,IAAM,UAAU,GAAG,YAAY,CAAC,UAAU,CAAC;QAC3C,IAAM,IAAI,GAAG,YAAY,CAAC,IAAI,CAAC;QAE/B,SAAS;QACT,IAAI,SAAoB,CAAC;QACzB,IAAG,IAAI,EAAE;YACL,IAAG,OAAO,IAAI,KAAK,QAAQ,EAAE;gBACzB,MAAM,IAAI,KAAK,CAAC,oCAAoC,CAAC,CAAC;aACzD;YAED,SAAS,GAAG,CAAC,IAAI,qBAAS,CAAC,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;SACzF;aAAM;YACH,SAAS,GAAG,UAAU,CAAC;SAC1B;QAED,OAAO,SAAS,CAAC,QAAQ,CAAC,eAAM,CAAC,CAAC;IACtC,CAAC;IAED;;;;;;;;;;OAUG;IACW,aAAK,GAAnB,UAAoB,UAAkB;QAClC,eAAe;QACf,IAAM,UAAU,GAAG,eAAM,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;QAE5C,gBAAgB;QAChB,IAAI,IAA2B,CAAC;QAChC,IAAG,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,UAAU,IAAI,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,UAAU,EAAE;YACzE,eAAe;YACf,IAAI,GAAG,IAAI,qBAAS,CAAC,UAAU,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;YAEnD,8BAA8B;YAC9B,UAAU,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;YAC9B,UAAU,CAAC,QAAQ,IAAI,EAAE,CAAC;SAC7B;QAED,OAAO,IAAI,2BAAY,CAAC,EAAE,UAAU,EAAE,UAAU,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC;IACpE,CAAC;IACL,cAAC;AAAD,CAhEA,AAgEC,IAAA;AAhEY,0BAAO;AAkEpB,kFAAkF;AAClF,IAAM,CAAC,GAAc,OAAO,CAAC","file":"","sourceRoot":"/","sourcesContent":["import { Formatter } from './Formatter';\r\nimport { CipherParams } from '../lib/CipherParams';\r\nimport { WordArray } from '../lib/WordArray';\r\nimport { Base64 } from '../enc/Base64';\r\n\r\nexport class OpenSSL {\r\n    /**\r\n     * Converts a cipher params object to an OpenSSL-compatible string.\r\n     *\r\n     * @param cipherParams The cipher params object.\r\n     *\r\n     * @return The OpenSSL-compatible string.\r\n     *\r\n     * @example\r\n     *\r\n     *     let openSSLString = OpenSSLFormatter.stringify(cipherParams);\r\n     */\r\n    public static stringify(cipherParams: CipherParams): string {\r\n        if(!cipherParams.ciphertext) {\r\n            throw new Error('missing ciphertext in params');\r\n        }\r\n\r\n        // Shortcuts\r\n        const ciphertext = cipherParams.ciphertext;\r\n        const salt = cipherParams.salt;\r\n\r\n        // Format\r\n        let wordArray: WordArray;\r\n        if(salt) {\r\n            if(typeof salt === 'string') {\r\n                throw new Error('salt is expected to be a WordArray');\r\n            }\r\n\r\n            wordArray = (new WordArray([0x53616c74, 0x65645f5f])).concat(salt).concat(ciphertext);\r\n        } else {\r\n            wordArray = ciphertext;\r\n        }\r\n\r\n        return wordArray.toString(Base64);\r\n    }\r\n\r\n    /**\r\n     * Converts an OpenSSL-compatible string to a cipher params object.\r\n     *\r\n     * @param openSSLStr The OpenSSL-compatible string.\r\n     *\r\n     * @return The cipher params object.\r\n     *\r\n     * @example\r\n     *\r\n     *     let cipherParams = OpenSSLFormatter.parse(openSSLString);\r\n     */\r\n    public static parse(openSSLStr: string): CipherParams {\r\n        // Parse base64\r\n        const ciphertext = Base64.parse(openSSLStr);\r\n\r\n        // Test for salt\r\n        let salt: WordArray | undefined;\r\n        if(ciphertext.words[0] === 0x53616c74 && ciphertext.words[1] === 0x65645f5f) {\r\n            // Extract salt\r\n            salt = new WordArray(ciphertext.words.slice(2, 4));\r\n\r\n            // Remove salt from ciphertext\r\n            ciphertext.words.splice(0, 4);\r\n            ciphertext.sigBytes -= 16;\r\n        }\r\n\r\n        return new CipherParams({ ciphertext: ciphertext, salt: salt });\r\n    }\r\n}\r\n\r\n// type guard for OpenSSL formatter (to ensure it has the required static methods)\r\nconst _: Formatter = OpenSSL;"]}