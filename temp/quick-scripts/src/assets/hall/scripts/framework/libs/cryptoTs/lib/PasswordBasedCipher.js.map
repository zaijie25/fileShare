{"version":3,"sources":["assets\\hall\\scripts\\framework\\libs\\cryptoTs\\lib\\PasswordBasedCipher.ts"],"names":[],"mappings":"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","file":"","sourceRoot":"/","sourcesContent":["import { SerializableCipher } from './SerializableCipher';\r\nimport { WordArray } from './WordArray';\r\nimport { Cipher } from './Cipher';\r\nimport { BufferedBlockAlgorithmConfig } from './BufferedBlockAlgorithmConfig';\r\nimport { OpenSSL } from '../format/OpenSSL';\r\nimport { CipherParams } from './CipherParams';\r\nimport { Formatter } from '../format/Formatter';\r\nimport { OpenSSLKdf } from '../kdf/OpenSSLKdf';\r\n\r\nexport class PasswordBasedCipher {\r\n    public static cfg: BufferedBlockAlgorithmConfig = {\r\n        blockSize: 4,\r\n        iv: new WordArray([]),\r\n        format: OpenSSL,\r\n        kdf: OpenSSLKdf\r\n    };\r\n\r\n    /**\r\n     * Encrypts a message using a password.\r\n     *\r\n     * @param cipher The cipher algorithm to use.\r\n     * @param message The message to encrypt.\r\n     * @param password The password.\r\n     * @param cfg (Optional) The configuration options to use for this operation.\r\n     *\r\n     * @return A cipher params object.\r\n     *\r\n     * @example\r\n     *\r\n     *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(AES, message, 'password');\r\n     *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(AES, message, 'password', { format: OpenSSL });\r\n     */\r\n    public static encrypt(\r\n        cipher: typeof Cipher,\r\n        message: WordArray | string,\r\n        password: string,\r\n        cfg?: BufferedBlockAlgorithmConfig\r\n    ): CipherParams {\r\n        // Apply config defaults\r\n        const config = Object.assign({}, this.cfg, cfg);\r\n\r\n        // Check if we have a kdf\r\n        if(config.kdf === undefined) {\r\n            throw new Error('missing kdf in config');\r\n        }\r\n\r\n        // Derive key and other params\r\n        const derivedParams: CipherParams = config.kdf.execute(password, cipher.keySize, cipher.ivSize);\r\n\r\n        // Check if we have an IV\r\n        if(derivedParams.iv !== undefined) {\r\n            // Add IV to config\r\n            config.iv = derivedParams.iv;\r\n        }\r\n\r\n        // Encrypt\r\n        const ciphertext: CipherParams = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, config);\r\n\r\n        // Mix in derived params\r\n        return ciphertext.extend(derivedParams);\r\n    }\r\n\r\n    /**\r\n     * Decrypts serialized ciphertext using a password.\r\n     *\r\n     * @param cipher The cipher algorithm to use.\r\n     * @param ciphertext The ciphertext to decrypt.\r\n     * @param password The password.\r\n     * @param cfg (Optional) The configuration options to use for this operation.\r\n     *\r\n     * @return The plaintext.\r\n     *\r\n     * @example\r\n     *\r\n     *     var plaintext = PasswordBasedCipher.decrypt(AES, formattedCiphertext, 'password', { format: OpenSSL });\r\n     *     var plaintext = PasswordBasedCipher.decrypt(AES, ciphertextParams, 'password', { format: OpenSSL });\r\n     */\r\n    public static decrypt(\r\n        cipher: typeof Cipher,\r\n        ciphertext: CipherParams | string,\r\n        password: string,\r\n        cfg?: BufferedBlockAlgorithmConfig\r\n    ): WordArray {\r\n        // Apply config defaults\r\n        const config = Object.assign({}, this.cfg, cfg);\r\n\r\n        // Check if we have a kdf\r\n        if(config.format === undefined) {\r\n            throw new Error('missing format in config');\r\n        }\r\n\r\n        // Convert string to CipherParams\r\n        ciphertext = this._parse(ciphertext, config.format);\r\n\r\n        // Check if we have a kdf\r\n        if(config.kdf === undefined) {\r\n            throw new Error('the key derivation function must be set');\r\n        }\r\n\r\n        // Derive key and other params\r\n        const derivedParams = config.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);\r\n\r\n        // Check if we have an IV\r\n        if(derivedParams.iv !== undefined) {\r\n            // Add IV to config\r\n            config.iv = derivedParams.iv;\r\n        }\r\n\r\n        // Decrypt\r\n        const plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, config);\r\n\r\n        return plaintext;\r\n    }\r\n\r\n    /**\r\n     * Converts serialized ciphertext to CipherParams,\r\n     * else assumed CipherParams already and returns ciphertext unchanged.\r\n     *\r\n     * @param ciphertext The ciphertext.\r\n     * @param format The formatting strategy to use to parse serialized ciphertext.\r\n     *\r\n     * @return The unserialized ciphertext.\r\n     *\r\n     * @example\r\n     *\r\n     *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);\r\n     */\r\n    public static _parse(ciphertext: CipherParams | string, format: Formatter): CipherParams {\r\n        if(typeof ciphertext === 'string') {\r\n            return format.parse(ciphertext);\r\n        } else {\r\n            return ciphertext;\r\n        }\r\n    }\r\n}"]}